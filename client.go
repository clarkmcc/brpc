package brpc

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/hashicorp/yamux"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
	"net"
)

var DefaultDialer net.Dialer

type ServiceRegisterFunc[Service any] func(registrar grpc.ServiceRegistrar)

type Client[Service any] struct {
	Dialer func(ctx context.Context, target string) (net.Conn, error)

	// The underlying net.Conn obtained from the Dialer
	conn        net.Conn
	session     *yamux.Session
	grpcConn    net.Conn
	server      *grpc.Server
	grpcSession *yamux.Session
	uuid        uuid.UUID
}

func Dial[Service any](target string, register ServiceRegisterFunc[Service]) (*Client[Service], error) {
	return DialContext(context.Background(), target, register)
}

func DialContext[Service any](ctx context.Context, target string, register ServiceRegisterFunc[Service]) (*Client[Service], error) {
	c := &Client[Service]{
		uuid: uuid.New(),
		Dialer: func(ctx context.Context, target string) (net.Conn, error) {
			return DefaultDialer.DialContext(ctx, "tcp", target)
		},
	}
	return c, c.connect(ctx, target, register)
}

func (c *Client[Service]) connect(ctx context.Context, target string, register ServiceRegisterFunc[Service]) error {
	var err error
	c.conn, err = c.Dialer(ctx, target)
	if err != nil {
		return err
	}
	c.session, err = yamux.Client(c.conn, nil)
	if err != nil {
		return ErrYamuxNegotiationFailed{inner: err, code: ErrorCodeCreatingYamuxClient}
	}

	// Open a stream just to negotiate the client id, then close it
	err = negotiateConnIdClient(c.session.Open, c.uuid)
	if err != nil {
		return fmt.Errorf("negotiating client id: %w", err)
	}

	// Wait for server to open a connection for server -> client gRPC
	grpcConn, err := c.session.Accept()
	if err != nil {
		return fmt.Errorf("accepting grpc session: %w", err)
	}
	c.grpcSession, err = yamux.Server(grpcConn, nil)
	if err != nil {
		return fmt.Errorf("creating grpc session: %w", err)
	}

	// Open a stream for the gRPC connection
	c.grpcConn, err = c.session.Open()
	if err != nil {
		return ErrYamuxNegotiationFailed{inner: err, code: ErrorCodeOpeningGrpcConnection}
	}

	// At this point we have:
	// 1. A real-world TCP connection (c.conn)
	// 2. A multiplexed session (c.session)
	// 3. A net.Conn multiplexed on top of session (c.grpcConn)
	c.server = grpc.NewServer()
	register(c.server)
	return nil
}

func (c *Client[Service]) Serve() error {
	return c.server.Serve(c.grpcSession)
}

func (c *Client[Service]) Close() error {
	// Close the real TCP connection
	// todo: do we need to close the multiplexed sessions?
	return c.conn.Close()
}

// ContextDialer returns a grpc.DialOption that uses the client's Dialer
// rather than the default gRPC Dialer. This allows the gRPC client to
// operate using a single multiplexed TCP connection.
func (c *Client[Service]) ContextDialer() grpc.DialOption {
	return grpc.WithContextDialer(func(ctx context.Context, s string) (net.Conn, error) {
		if c.grpcConn == nil {
			return nil, ErrClientNotConnected
		}
		return c.grpcConn, nil
	})
}

func (c *Client[Service]) AddConnectionIdentifier() grpc.DialOption {
	return grpc.WithUnaryInterceptor(func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(metadataKey, c.uuid.String()))
		return invoker(ctx, method, req, reply, cc, opts...)
	})
}

// ConstructClient constructs a gRPC client for ClientService. It accepts the brpc.Client
// and a constructor function generated by protoc.
func ConstructClient[ClientService, Service any](client *Client[Service], fn func(cc grpc.ClientConnInterface) ClientService) (ClientService, error) {
	var def ClientService
	conn, err := grpc.Dial("",
		client.ContextDialer(),
		client.AddConnectionIdentifier(),
		grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return def, err
	}
	return fn(conn), nil
}
