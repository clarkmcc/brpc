package brpc

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/hashicorp/yamux"
	"go.uber.org/multierr"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
	"net"
)

var DefaultDialer net.Dialer

// ServiceRegisterFunc is a function responsible for registering a gRPC service
// that is served by a brpc client, for a brpc server. Clients must provide one
// of these when dialing a brpc server.
type ServiceRegisterFunc[Service any] func(registrar grpc.ServiceRegistrar)

// ClientConn is a bidirectional gRPC connection that is generic over S, the gRPC
// server that we're connecting to. Callers use this connection to
//  1. Serve a gRPC server that is accessible to a brpc server.
//  2. Construct a gRPC client that can call the gRPC server.
type ClientConn[S any] struct {
	Dialer func(ctx context.Context, target string) (net.Conn, error)

	conn        net.Conn       // The underlying net.Conn obtained from the Dialer
	session     *yamux.Session // A session that multiplexes all communication
	grpcConn    net.Conn       // A net.Conn over session reserved for server->client RPCs
	grpcSession *yamux.Session // A yamux.Session over session that multiplexes all client->server RPCs
	server      *grpc.Server   // The gRPC server that is served over the grpcConn for server->client RPCs
	uuid        uuid.UUID      // The client ID assigned by the server. Must be present on all client->server RPCs.
}

func Dial[Service any](target string, register ServiceRegisterFunc[Service]) (*ClientConn[Service], error) {
	return DialContext(context.Background(), target, register)
}

func DialContext[Service any](ctx context.Context, target string, register ServiceRegisterFunc[Service]) (*ClientConn[Service], error) {
	c := &ClientConn[Service]{
		Dialer: func(ctx context.Context, target string) (net.Conn, error) {
			return DefaultDialer.DialContext(ctx, "tcp", target)
		},
	}
	return c, c.connect(ctx, target, register)
}

func (c *ClientConn[S]) connect(ctx context.Context, target string, register ServiceRegisterFunc[S]) (err error) {
	c.conn, err = c.Dialer(ctx, target)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			multierr.AppendFunc(&err, c.conn.Close)
		}
	}()
	c.session, err = yamux.Client(c.conn, nil)
	if err != nil {
		return ErrYamuxNegotiationFailed{inner: err, code: ErrorCodeCreatingYamuxClient}
	}

	c.uuid, err = getClientID(c.session)
	if err != nil {
		return fmt.Errorf("getting client id from server: %w", err)
	}

	// Wait for server to open a connection for server -> client gRPC
	grpcConn, err := c.session.Accept()
	if err != nil {
		return fmt.Errorf("accepting connection for server->client grpc: %w", err)
	}
	c.grpcSession, err = yamux.Server(grpcConn, nil)
	if err != nil {
		return fmt.Errorf("creating double-multiplexed session for client->server grpc: %w", err)
	}

	// Open a stream for the gRPC connection
	c.grpcConn, err = c.session.Open()
	if err != nil {
		return fmt.Errorf("opening multiplexed client->server gprc connection: %w", err)
	}

	c.server = grpc.NewServer()
	register(c.server)

	// Start serving the client's gRPC server
	go c.serve()
	return nil
}

func (c *ClientConn[S]) serve() error {
	return c.server.Serve(c.grpcSession)
}

func (c *ClientConn[S]) Close() error {
	// Close the gRPC server so that .Serve doesn't freak out
	// Then we close session, which closes all connections made
	// over the session, as well as the underlying connection.
	if c.server != nil {
		// This also closes c.conn
		c.server.GracefulStop()
	}
	return c.session.Close()
}

// WithUnaryConnectionIdentifier is a grpc.DialOption that adds the client's UUID to
// all unary requests. This is required if the server intends to call back to
// the client's gRPC server.
func (c *ClientConn[S]) WithUnaryConnectionIdentifier() grpc.DialOption {
	return grpc.WithUnaryInterceptor(func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(metadataClientIDKey, c.uuid.String()))
		return invoker(ctx, method, req, reply, cc, opts...)
	})
}

// WithStreamConnectionIdentifier is a grpc.DialOption that adds the client's UUID to
// all stream requests. This is required if the server intends to call back to
// the client's gRPC server.
func (c *ClientConn[S]) WithStreamConnectionIdentifier() grpc.DialOption {
	return grpc.WithStreamInterceptor(func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {
		ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(metadataClientIDKey, c.uuid.String()))
		return streamer(ctx, desc, cc, method, opts...)
	})
}

// Client constructs a gRPC client for ClientService. It accepts the brpc.ClientConn
// and a constructor function generated by protoc.
func Client[ClientService, Service any](conn *ClientConn[Service], fn func(cc grpc.ClientConnInterface) ClientService) (ClientService, error) {
	var def ClientService
	c, err := dial(conn.grpcConn,
		conn.WithUnaryConnectionIdentifier(),
		conn.WithStreamConnectionIdentifier(),
		grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return def, err
	}
	return fn(c), nil
}
