package brpc

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/hashicorp/yamux"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
	"net"
)

var DefaultDialer net.Dialer

type ServiceRegisterFunc[Service any] func(registrar grpc.ServiceRegistrar)

type ClientConn[Service any] struct {
	Dialer func(ctx context.Context, target string) (net.Conn, error)

	// The underlying net.Conn obtained from the Dialer
	conn        net.Conn
	session     *yamux.Session
	grpcConn    net.Conn
	server      *grpc.Server
	grpcSession *yamux.Session
	uuid        uuid.UUID
}

func Dial[Service any](target string, register ServiceRegisterFunc[Service]) (*ClientConn[Service], error) {
	return DialContext(context.Background(), target, register)
}

func DialContext[Service any](ctx context.Context, target string, register ServiceRegisterFunc[Service]) (*ClientConn[Service], error) {
	c := &ClientConn[Service]{
		uuid: uuid.New(),
		Dialer: func(ctx context.Context, target string) (net.Conn, error) {
			return DefaultDialer.DialContext(ctx, "tcp", target)
		},
	}
	return c, c.connect(ctx, target, register)
}

func (c *ClientConn[Service]) connect(ctx context.Context, target string, register ServiceRegisterFunc[Service]) error {
	var err error
	c.conn, err = c.Dialer(ctx, target)
	if err != nil {
		return err
	}
	c.session, err = yamux.Client(c.conn, nil)
	if err != nil {
		return ErrYamuxNegotiationFailed{inner: err, code: ErrorCodeCreatingYamuxClient}
	}

	c.uuid, err = getClientID(c.session)
	if err != nil {
		return fmt.Errorf("getting client id from server: %w", err)
	}

	// Wait for server to open a connection for server -> client gRPC
	grpcConn, err := c.session.Accept()
	if err != nil {
		return fmt.Errorf("accepting connection for server->client grpc: %w", err)
	}
	c.grpcSession, err = yamux.Server(grpcConn, nil)
	if err != nil {
		return fmt.Errorf("creating double-multiplexed session for client->server grpc: %w", err)
	}

	// Open a stream for the gRPC connection
	c.grpcConn, err = c.session.Open()
	if err != nil {
		return fmt.Errorf("opening multiplexed client->server gprc connection: %w", err)
	}

	c.server = grpc.NewServer()
	register(c.server)

	// Start serving the client's gRPC server
	go c.serve()
	return nil
}

func (c *ClientConn[Service]) serve() error {
	return c.server.Serve(c.grpcSession)
}

func (c *ClientConn[Service]) Close() error {
	// Close the real TCP connection
	// todo: do we need to close the multiplexed sessions?
	return c.conn.Close()
}

func (c *ClientConn[Service]) AddConnectionIdentifier() grpc.DialOption {
	return grpc.WithUnaryInterceptor(func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		ctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(metadataClientIDKey, c.uuid.String()))
		return invoker(ctx, method, req, reply, cc, opts...)
	})
}

// Client constructs a gRPC client for ClientService. It accepts the brpc.ClientConn
// and a constructor function generated by protoc.
func Client[ClientService, Service any](conn *ClientConn[Service], fn func(cc grpc.ClientConnInterface) ClientService) (ClientService, error) {
	var def ClientService
	c, err := grpc.Dial("",
		withContextDialer(conn.grpcConn),
		conn.AddConnectionIdentifier(),
		grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return def, err
	}
	return fn(c), nil
}
